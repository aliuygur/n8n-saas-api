# N8N SaaS Platform - Copilot Instructions

## Project Overview

This is a SaaS platform for one-click n8n deployment on GKE Autopilot with complete per-customer isolation. The application uses Encore.dev framework for API management and deploys isolated N8N instances for each customer using SQLite databases.

## Core Architecture

### Framework & Technologies

- **API Framework**: Encore.dev with private APIs (`//encore:api private`)
- **Database**: PostgreSQL with SQLC for type-safe queries (for SaaS platform management)
- **Customer N8N**: Standard mode with SQLite (complete isolation)
- **Kubernetes**: GKE Autopilot with per-customer namespace deployment
- **External Access**: Single Cloudflare Tunnel for all customers
- **Multi-tenancy**: Complete isolation via separate N8N instances and SQLite databases

### Key Architectural Decisions

1. **Simple Per-Customer Deployment**:
   - **Customer N8N**: Each customer gets isolated N8N instance with SQLite
   - **No Shared Resources**: No shared PostgreSQL, Redis, or workers between customers
2. **Complete Isolation**: Each N8N instance is fully isolated with own database
3. **Standard Mode**: N8N runs in standard mode (not queue mode)
4. **Single Tunnel**: One Cloudflare Tunnel handles routing to all customer instances
5. **Private APIs**: All provisioning APIs are private (internal use only)

## Database Schema Conventions

- Use `VARCHAR` without length limits (not `VARCHAR(255)`)
- All string columns should be `NOT NULL` with default `''`
- Use `TIMESTAMP` without timezone for datetime columns
- Follow SQLC naming conventions for queries

## Service Structure

### `/internal/services/provisioning`

- **Purpose**: Customer provisioning and isolated n8n instance management
- **Key Functions**:
  - `CreateCustomer`: Creates customer record in SaaS platform database
  - `DeployN8NInstance`: Deploys isolated n8n instance with SQLite in dedicated namespace
- **Dependencies**: GKE client for customer instance deployment

### `/internal/gke/client.go`

- **Purpose**: Customer-specific isolated n8n instance management
- **Key Functions**:
  - `DeployN8NInstance`: Creates namespace, n8n deployment with SQLite, service, ingress
  - Each instance is completely isolated with own SQLite database
  - Uses Go Kubernetes client for customer instance deployment
- **Important**: NO ingress creation - uses Cloudflare Tunnel instead

## Deployment Model

### Infrastructure Setup

1. **Simple Infrastructure** (Minimal Components):

   - Deploy Cloudflare Tunnel in `cloudflare-tunnel` namespace via `k8s/cloudflare-tunnel.yaml`
   - Use `./deploy-infrastructure.sh` for automated deployment
   - Set `CLOUDFLARE_TUNNEL_TOKEN` environment variable when ready

2. **API Deployment**:
   - Run `./deploy.sh` for initial setup
   - Deploy API server with `encore run`

### Customer Provisioning Flow

1. API creates customer record in SaaS platform database
2. Creates dedicated customer namespace
3. Deploys isolated N8N instance using `k8s/n8n-instance.yaml` template
4. Each N8N instance uses SQLite for complete data isolation
5. Customer accesses via Cloudflare Tunnel routing

## Development Guidelines

### Code Style

- Use Go standard conventions
- **Customer Isolation**: Each N8N instance is completely isolated
- **Simple Architecture**: No shared databases or complex infrastructure
- **Template-based Deployment**: Use `n8n-instance.yaml` template for customer deployment
- Use SQLC for SaaS platform database operations only
- **API Paths**: Base URL is `api.instol.cloud`, so don't add `/api` prefix to paths
- **User Endpoints**: Use `/me` prefix for user-specific endpoints (e.g., `/me/instances`)
- **Code Organization**: Keep type definitions close to their methods, not separated at the top
- **Logging**: Use `rlog.Debug` for routine operations, `rlog.Info` for important events, `rlog.Warn` for warnings, `rlog.Error` for errors

### Security Considerations

- Complete customer isolation via separate N8N instances
- Each N8N instance has own SQLite database (no shared data)
- Namespace separation for each customer instance
- Ingress and SSL certificates per customer instance
- No cross-customer communication or data access possible
- **Authorization**: Users can only mutate (create, read, update, delete) their own instances
- **Ownership Verification**: Always verify instance ownership before allowing mutations
- **Error Handling**: Use `errs.PermissionDenied` for authorization failures

### Testing Strategy

- Test customer instance isolation
- Verify SQLite database separation
- Verify customer namespace isolation for n8n main instances
- Test cross-namespace connectivity between customer instances and shared resources
- Test SQLite database isolation
- Verify namespace cleanup on customer deletion

## Common Pitfalls to Avoid

1. **Don't create shared infrastructure** - each customer gets isolated N8N instance
2. **Don't use PostgreSQL/Redis** - customers use SQLite for complete isolation
3. **Don't use ingress for external access** - we use Cloudflare Tunnel routing
4. **Don't share any resources between customers** - complete isolation with SQLite
5. **Don't forget namespace cleanup** - implement proper customer deletion
6. **Don't use queue mode** - N8N runs in standard mode with SQLite

## Key Files to Understand

- `internal/gke/client.go`: Customer N8N instance deployment operations
- `internal/services/provisioning/service.go`: Customer lifecycle management
- `k8s/n8n-instance.yaml`: N8N instance template with SQLite
- `k8s/cloudflare-tunnel.yaml`: Cloudflare tunnel deployment in `cloudflare-tunnel` namespace
- `k8s/deploy-infrastructure.sh`: Simple infrastructure deployment (only Cloudflare tunnel)
- `sqlc.yaml`: Database code generation config (for SaaS platform only)
- `deploy.sh`: API deployment script

## Environment Variables

- `CLOUDFLARE_TUNNEL_TOKEN`: Required for tunnel authentication
- Standard Encore.dev environment variables for SaaS platform database and API

## Multi-tenancy Implementation

### Simple Per-Customer Isolation:

- **N8N Instances**: Each customer gets completely isolated N8N instance
- **SQLite Database**: Each N8N instance uses its own SQLite database
- **Kubernetes Namespace**: Each customer instance in dedicated namespace
- **No Shared Resources**: No shared PostgreSQL, Redis, or workers

### Customer-Specific Resources:

Each customer receives:

- Dedicated Kubernetes namespace (`n8n-customer-{id}`)
- Dedicated N8N deployment with SQLite database
- Dedicated persistent storage for SQLite and N8N data
- Dedicated service and ingress with SSL certificate
- Complete isolation - no cross-customer communication possible

### Architecture Benefits:

- **Complete Isolation**: No shared resources, no data mixing risks
- **Simple Architecture**: No complex shared infrastructure
- **Easy Scaling**: Each customer instance scales independently
- **Security**: Perfect isolation with SQLite databases
- **Reliability**: Customer issues don't affect other customers

**Note**: One customer can have multiple N8N instances, each completely isolated.

## External Access Pattern

- Single Cloudflare Tunnel serves all N8N instances
- DNS routing based on subdomain per N8N instance
- Each instance has dedicated ingress and SSL certificate
- Cloudflare tunnel routes traffic to appropriate customer instance

This architecture provides complete isolation with simple deployment model using N8N standard mode and SQLite.
