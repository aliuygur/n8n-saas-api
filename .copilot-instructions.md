# N8N SaaS Platform - Copilot Instructions

## Project Overview

This is a SaaS platform for one-click n8n deployment on GKE Autopilot with namespace-based n8n instance isolation. The application uses Encore.dev framework with programmatic Kubernetes resource management via Go client.

## Core Architecture

### Framework & Technologies

- **API Framework**: Encore.dev with private APIs (`//encore:api private`)
- **Database**: PostgreSQL with SQLC for type-safe queries
- **Kubernetes**: GKE Autopilot with programmatic resource creation
- **External Access**: Single Cloudflare Tunnel (no ingress)
- **Multi-tenancy**: Namespace-based n8n instance isolation

### Key Architectural Decisions

1. **No Static YAML**: All Kubernetes resources created programmatically via Go client
2. **Single Tunnel**: One Cloudflare Tunnel handles all customers (not per-customer)
3. **Namespace Isolation**: Each n8n instance gets dedicated Kubernetes namespace
4. **Private APIs**: All provisioning APIs are private (internal use only)

## Database Schema Conventions

- Use `VARCHAR` without length limits (not `VARCHAR(255)`)
- All string columns should be `NOT NULL` with default `''`
- Use `TIMESTAMP` without timezone for datetime columns
- Follow SQLC naming conventions for queries

## Service Structure

### `/internal/services/provisioning`

- **Purpose**: Customer provisioning and n8n instance management
- **Key Functions**:
  - `CreateCustomer`: Creates customer record
  - `DeployN8NInstance`: Deploys complete n8n stack programmatically in dedicated namespace
- **Dependencies**: GKE client, database operations

### `/internal/gke/client.go`

- **Purpose**: Kubernetes resource management
- **Key Functions**:
  - `DeployN8NInstance`: Creates namespace, deployments, services, secrets, PVCs
  - Uses Go Kubernetes client exclusively (no YAML files)
- **Important**: NO ingress creation - uses Cloudflare Tunnel instead

## Deployment Model

### Infrastructure Setup

1. Deploy single Cloudflare Tunnel (`k8s/cloudflare-tunnel.yaml`)
2. Set `CLOUDFLARE_TUNNEL_TOKEN` environment variable
3. Run `./deploy.sh` for initial setup
4. Deploy API server with `encore run`

### Customer Provisioning Flow

1. API creates customer record in database
2. For each n8n instance: creates dedicated Kubernetes namespace
3. Deploys n8n main + worker + PostgreSQL + Redis in instance namespace
4. Customer accesses via Cloudflare Tunnel routing

## Development Guidelines

### Code Style

- Use Go standard conventions
- Prefer programmatic resource creation over static manifests
- Keep n8n instances isolated per namespace
- Use SQLC for all database operations

### Security Considerations

- N8n instance isolation is critical - always use namespace-based separation
- Secrets are created per n8n instance namespace
- No shared resources between n8n instances (except Cloudflare Tunnel)

### Testing Strategy

- Test n8n instance isolation thoroughly
- Verify namespace cleanup on n8n instance deletion
- Test n8n instance health checks

## Common Pitfalls to Avoid

1. **Don't create static YAML files** - everything should be programmatic
2. **Don't use ingress** - we use Cloudflare Tunnel for external access
3. **Don't share resources between n8n instances** - strict namespace isolation
4. **Don't forget namespace cleanup** - implement proper n8n instance deletion

## Key Files to Understand

- `internal/gke/client.go`: Core Kubernetes operations
- `internal/services/provisioning/service.go`: Customer lifecycle management
- `k8s/cloudflare-tunnel.yaml`: Single tunnel deployment (only static YAML)
- `sqlc.yaml`: Database code generation config
- `deploy.sh`: Infrastructure deployment script

## Environment Variables

- `CLOUDFLARE_TUNNEL_TOKEN`: Required for tunnel authentication
- Standard Encore.dev environment variables for database and API

## Multi-tenancy Implementation

Each n8n instance receives:

- Dedicated Kubernetes namespace (`n8n-instance-{id}`)
- Isolated n8n main deployment
- Isolated n8n worker deployment
- Isolated PostgreSQL database
- Isolated Redis instance
- Isolated secrets and configs

**Note**: One customer can have multiple n8n instances, each in its own namespace.

## External Access Pattern

- Single Cloudflare Tunnel serves all n8n instances
- DNS routing based on subdomain/path per n8n instance
- Manual DNS record creation required per n8n instance
- No ingress controllers or LoadBalancers used

This architecture provides secure, scalable multi-tenant n8n hosting with minimal operational overhead.
