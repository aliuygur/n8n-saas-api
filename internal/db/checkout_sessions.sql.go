// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: checkout_sessions.sql

package db

import (
	"context"
)

const createCheckoutSession = `-- name: CreateCheckoutSession :one
INSERT INTO checkout_sessions (
    user_id,
    polar_checkout_id,
    subdomain,
    user_email,
    success_url,
    return_url,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, polar_checkout_id, subdomain, user_email, status, success_url, return_url, created_at, updated_at, completed_at
`

type CreateCheckoutSessionParams struct {
	UserID          string `json:"user_id"`
	PolarCheckoutID string `json:"polar_checkout_id"`
	Subdomain       string `json:"subdomain"`
	UserEmail       string `json:"user_email"`
	SuccessUrl      string `json:"success_url"`
	ReturnUrl       string `json:"return_url"`
	Status          string `json:"status"`
}

func (q *Queries) CreateCheckoutSession(ctx context.Context, arg CreateCheckoutSessionParams) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, createCheckoutSession,
		arg.UserID,
		arg.PolarCheckoutID,
		arg.Subdomain,
		arg.UserEmail,
		arg.SuccessUrl,
		arg.ReturnUrl,
		arg.Status,
	)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PolarCheckoutID,
		&i.Subdomain,
		&i.UserEmail,
		&i.Status,
		&i.SuccessUrl,
		&i.ReturnUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getCheckoutSessionByID = `-- name: GetCheckoutSessionByID :one
SELECT id, user_id, polar_checkout_id, subdomain, user_email, status, success_url, return_url, created_at, updated_at, completed_at FROM checkout_sessions
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCheckoutSessionByID(ctx context.Context, id string) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, getCheckoutSessionByID, id)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PolarCheckoutID,
		&i.Subdomain,
		&i.UserEmail,
		&i.Status,
		&i.SuccessUrl,
		&i.ReturnUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getCheckoutSessionByPolarID = `-- name: GetCheckoutSessionByPolarID :one
SELECT id, user_id, polar_checkout_id, subdomain, user_email, status, success_url, return_url, created_at, updated_at, completed_at FROM checkout_sessions
WHERE polar_checkout_id = $1
LIMIT 1
`

func (q *Queries) GetCheckoutSessionByPolarID(ctx context.Context, polarCheckoutID string) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, getCheckoutSessionByPolarID, polarCheckoutID)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PolarCheckoutID,
		&i.Subdomain,
		&i.UserEmail,
		&i.Status,
		&i.SuccessUrl,
		&i.ReturnUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const updateCheckoutSessionStatus = `-- name: UpdateCheckoutSessionStatus :exec
UPDATE checkout_sessions
SET status = $2,
    updated_at = NOW(),
    completed_at = CASE WHEN $2 = 'completed' THEN NOW() ELSE completed_at END
WHERE id = $1
`

type UpdateCheckoutSessionStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateCheckoutSessionStatus(ctx context.Context, arg UpdateCheckoutSessionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckoutSessionStatus, arg.ID, arg.Status)
	return err
}
