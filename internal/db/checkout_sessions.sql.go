// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: checkout_sessions.sql

package db

import (
	"context"
)

const createCheckoutSession = `-- name: CreateCheckoutSession :one
INSERT INTO checkout_sessions (
    user_id,
    instance_id,
    checkout_id,
    subdomain,
    user_email,
    success_url,
    return_url,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, user_id, instance_id, subdomain, user_email, status, success_url, return_url, checkout_id, created_at, updated_at, completed_at
`

type CreateCheckoutSessionParams struct {
	UserID     string `json:"user_id"`
	InstanceID string `json:"instance_id"`
	CheckoutID string `json:"checkout_id"`
	Subdomain  string `json:"subdomain"`
	UserEmail  string `json:"user_email"`
	SuccessUrl string `json:"success_url"`
	ReturnUrl  string `json:"return_url"`
	Status     string `json:"status"`
}

func (q *Queries) CreateCheckoutSession(ctx context.Context, arg CreateCheckoutSessionParams) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, createCheckoutSession,
		arg.UserID,
		arg.InstanceID,
		arg.CheckoutID,
		arg.Subdomain,
		arg.UserEmail,
		arg.SuccessUrl,
		arg.ReturnUrl,
		arg.Status,
	)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.InstanceID,
		&i.Subdomain,
		&i.UserEmail,
		&i.Status,
		&i.SuccessUrl,
		&i.ReturnUrl,
		&i.CheckoutID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getCheckoutSessionByID = `-- name: GetCheckoutSessionByID :one
SELECT id, user_id, instance_id, subdomain, user_email, status, success_url, return_url, checkout_id, created_at, updated_at, completed_at FROM checkout_sessions
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCheckoutSessionByID(ctx context.Context, id string) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, getCheckoutSessionByID, id)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.InstanceID,
		&i.Subdomain,
		&i.UserEmail,
		&i.Status,
		&i.SuccessUrl,
		&i.ReturnUrl,
		&i.CheckoutID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getCheckoutSessionByProviderID = `-- name: GetCheckoutSessionByProviderID :one
SELECT id, user_id, instance_id, subdomain, user_email, status, success_url, return_url, checkout_id, created_at, updated_at, completed_at FROM checkout_sessions
WHERE checkout_id = $1
LIMIT 1
`

func (q *Queries) GetCheckoutSessionByProviderID(ctx context.Context, checkoutID string) (CheckoutSession, error) {
	row := q.db.QueryRowContext(ctx, getCheckoutSessionByProviderID, checkoutID)
	var i CheckoutSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.InstanceID,
		&i.Subdomain,
		&i.UserEmail,
		&i.Status,
		&i.SuccessUrl,
		&i.ReturnUrl,
		&i.CheckoutID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listCheckoutSessions = `-- name: ListCheckoutSessions :many
SELECT id, user_id, instance_id, subdomain, user_email, status, success_url, return_url, checkout_id, created_at, updated_at, completed_at FROM checkout_sessions
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListCheckoutSessions(ctx context.Context, limit int32) ([]CheckoutSession, error) {
	rows, err := q.db.QueryContext(ctx, listCheckoutSessions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckoutSession
	for rows.Next() {
		var i CheckoutSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.InstanceID,
			&i.Subdomain,
			&i.UserEmail,
			&i.Status,
			&i.SuccessUrl,
			&i.ReturnUrl,
			&i.CheckoutID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCheckoutSessionCompleted = `-- name: UpdateCheckoutSessionCompleted :exec
UPDATE checkout_sessions
SET status = 'completed',
    instance_id = $2,
    updated_at = NOW(),
    completed_at = NOW()
WHERE id = $1 AND completed_at IS NULL
`

type UpdateCheckoutSessionCompletedParams struct {
	ID         string `json:"id"`
	InstanceID string `json:"instance_id"`
}

func (q *Queries) UpdateCheckoutSessionCompleted(ctx context.Context, arg UpdateCheckoutSessionCompletedParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckoutSessionCompleted, arg.ID, arg.InstanceID)
	return err
}

const updateCheckoutSessionStatus = `-- name: UpdateCheckoutSessionStatus :exec
UPDATE checkout_sessions
SET status = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateCheckoutSessionStatusParams struct {
	Status string `json:"status"`
	ID     string `json:"id"`
}

func (q *Queries) UpdateCheckoutSessionStatus(ctx context.Context, arg UpdateCheckoutSessionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckoutSessionStatus, arg.Status, arg.ID)
	return err
}
